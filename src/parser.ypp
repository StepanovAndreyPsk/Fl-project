%{
#include "node.hpp"
#include "codegen.hpp"
#include "parsing_context.hpp"

#include <iostream>
#include <string>
#include <cstdlib>
#include <cassert>
#include <optional>


using namespace std;

extern int yylex();

int yyerror(const char *p) {
    cerr << "Error! Unexpected token " << p << endl;
    return 1;
}

// codegen::CodeGenContext & codegenContext() {
//     static codegen::CodeGenContext ctx;
//     return ctx;
// }

parsingcontext::ParsingContext & parsingContext() {
    static parsingcontext::ParsingContext ctx;
    return ctx;
}

%}

%union {
    std::string *word;
    char sym;
    int num;
    bool boolean;
    AST::VarDecl *vardecl;
    AST::Identifier *ident;
    AST::Expression *expr;
    AST::DataType type;
    AST::VarAssign *varassign;
    AST::WhileLoop *whileloop;
    AST::CodeBlock *codeblock;
    AST::Statement *statement;
    AST::Skip *skip;
    AST::IfStatement *if_stmt;
    std::optional<AST::CodeBlock> *else_stmt;
}

%token <word> MAIN IF ELSE WHILE SKIP
%token <word> INT_TYPE BOOL_TYPE STRING_TYPE
%token <word> VAR
%token <word> STRING
%token <sym> SEP LP RP LB RB ASSIGN
%token <sym> PLUS MINUS MUL DIV POW
%token <word> EQ NEQ LT LE GT GE NOT AND OR
%token <num> INT
%token <boolean> TRUE_VAL FALSE_VAL

%left OR
%left AND
%left NOT
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left MUL DIV
%right POW

%type <vardecl> declaration; 
%type <expr> EXPR;
%type <type> type;
%type <expr> CONST;
%type <varassign> assignment;
%type <whileloop> while_statement;
%type <codeblock> code_block;
%type <statement> statement;
%type <skip> skip;
%type <if_stmt> if_statement;
%type <else_stmt> optional_else;

%%
start: MAIN LP RP code_block  {cout << "Main: " << endl;}

code_block: LB statements_seq RB {
    $$ = new AST::CodeBlock(AST::CurCodeBlock);
    AST::CurCodeBlock.clear();
}

statements_seq: statements_seq statement {}
| statement {}

statement: declaration {
    AST::CurCodeBlock.push_back($1);
}
| assignment {
    AST::CurCodeBlock.push_back($1);
}
| skip {
    AST::CurCodeBlock.push_back($1);
}
| if_statement {
    AST::CurCodeBlock.push_back($1);
}
| while_statement {
    AST::CurCodeBlock.push_back($1);
}
;

skip: SKIP SEP {
    $$ = new AST::Skip;
}

declaration: type VAR ASSIGN EXPR SEP {
    AST::Identifier *id = new AST::Identifier($1, *$2); delete $2;
    std::cerr << "id = " << intptr_t(id) << '\n';
    parsingContext().storeIdent(id->name, id);
    $$ = new AST::VarDecl(id, *$4);
}

type: INT_TYPE { $$ = AST::DataType::Int; }
| BOOL_TYPE { $$ = AST::DataType::Bool; }
| STRING_TYPE { $$ = AST::DataType::String; }

assignment: VAR ASSIGN EXPR SEP {
    $$ = new AST::VarAssign(parsingContext().loadIdent(*$1), *$3);
}

if_statement: IF LP EXPR RP code_block optional_else {
    $$ = new AST::IfStatement(*$3, *$5, *$6);
}

optional_else: ELSE code_block {
    $$ = new std::optional<AST::CodeBlock>{*$2};
}
| {
    $$ = new std::optional<AST::CodeBlock>;
}
;

while_statement: WHILE LP EXPR RP code_block {
    $$ = new AST::WhileLoop(*$3, *$5);
};

EXPR : CONST { $$ = $1; }
| MINUS EXPR {
    $$ = new AST::UnaryOp(AST::UnaryOpType::Minus, *$2);
}
| VAR { 
    std::cerr << "Looking for variable: " << *$1 << std::endl;
    // AST::PrintVarDict();
    $$ = parsingContext().loadIdent(*$1); 
}
| LP EXPR RP {
    $$ = $2;
}
| EXPR PLUS  EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Sum, *$3);
}
| EXPR MINUS EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Sub, *$3);
}
| EXPR MUL   EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Mult, *$3);
}
| EXPR DIV   EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Div, *$3);
}
| EXPR POW   EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Pow, *$3);
}
| NOT EXPR {
    $$ = new AST::UnaryOp(AST::UnaryOpType::Neg, *$2);
}
| EXPR AND EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::And, *$3);
}
| EXPR OR EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Or, *$3);
}
| EXPR EQ EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Eq, *$3);
}
| EXPR NEQ EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Neq, *$3);
}
| EXPR LE EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Leq, *$3);
}
| EXPR LT EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Les, *$3);
}
| EXPR GE EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Geq, *$3);
}
| EXPR GT EXPR {
    $$ = new AST::BinaryOp(*$1, AST::BinaryOpType::Gre, *$3);
}
;

CONST: INT { $$ = new AST::Constant($1); }
| STRING { $$ = new AST::Constant(*$1); delete $1; }
| TRUE_VAL { $$ = new AST::Constant($1); }
| FALSE_VAL { $$ = new AST::Constant($1); }

%%


int main(int argc, char* argv[])
{
    freopen(argv[1], "r", stdin);
    yyparse();
    fclose(stdin);

    return 0;
}
